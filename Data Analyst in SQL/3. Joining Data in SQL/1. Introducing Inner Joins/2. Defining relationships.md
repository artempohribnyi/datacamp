# 1. Defining relationships

Welcome back! Now that we have written our very first SQL joins, it's time to think more conceptually about the kinds of the relationships tables can have to each other.

# 2. One-to-many relationships

The first type of relationship we'll talk about is a one-to-many relationship. This is the most common type of relationship, one where a single entity can be associated with several entities. Think about a music library. One artist can produce many songs over their career. This is a one-to-many relationship. The same applies for authors and their books, directors and movie titles, and so on.

![image](https://github.com/artempohribnyi/datacamp/assets/113499718/9f8ca7c6-015a-460c-84b4-c4528430666c)

# 3. One-to-many relationships

Jane Austen wrote many books, and each of her books had just one author. In the table schema shown, each of her works are stored in the books table, and can be merged with the authors table using author_id from both tables.

![image](https://github.com/artempohribnyi/datacamp/assets/113499718/268157fb-c9d0-4598-b8e3-5d2d737728b5)

# 4. One-to-one relationships

A second type of relationship is a one-to-one relationship. One-to-one relationships imply unique pairings between entities and are therefore less common. A commonly held premise of forensic science is that no two fingerprints are identical, and therefore that a particular fingerprint can only be generated by one person. This is an example of a one-to-one relationship: one fingerprint for one finger.

![image](https://github.com/artempohribnyi/datacamp/assets/113499718/db50df75-9952-43a5-8c8e-6b16acca3485)

# 5. One-to-one relationships

Imagine fingerprint scanning at airport border control. Border control might have two tables in a database: a table of people and a table of their prints. Each person's fingerprint could be merged with the individuals table using their passport number. We won't cover this in detail here, but using a binary format is one way to store images, such as fingerprints, in a database. Note here that although an individual will have four fingerprints stored in the fingerprints table, this is not a one-to-many relationship. It is a one-to-one relationship, because a single individual - represented as one record on the individuals table - will have one set of fingerprints - represented as one record on the fingerprints table. The four different fingerprints are four different fields in each record.

![image](https://github.com/artempohribnyi/datacamp/assets/113499718/b7893ce0-44e6-4709-ad57-c7bbeb570e91)

# 6. Many-to-many relationships

The last type of relationship we'll discuss is a many-to-many relationship. An example of this is languages and countries. Here we show the official languages of Germany, Belgium and the Netherlands, where we see that many languages can be spoken in many countries. For example, Belgium has three official languages: French, German, and Dutch. Conversely, languages can be official in many countries: Dutch is an official language of both the Netherlands and Belgium, but not Germany.

![image](https://github.com/artempohribnyi/datacamp/assets/113499718/a86f87ba-3958-437c-846b-6291150b5ca6)

# 7. Let's practice!

Now that we have discussed the various relationships that can exist between tables, let's put this into practice!

# Relationships in our database

Now that you know more about the different types of relationships that can exist between tables, it's time to examine a few relationships in the countries database!

To answer questions about table relationships, you can explore the tables displayed as tabs in your console.

1. What best describes the relationship between code in the countries table and country_code in the cities table?

![image](https://github.com/artempohribnyi/datacamp/assets/113499718/ff578f01-2236-4ab2-b8cb-816e85a5d39e)

2. Which of these options best describes the relationship between the countries table and the languages table?

![image](https://github.com/artempohribnyi/datacamp/assets/113499718/a28b9966-7e35-421e-bc34-b53546f30fc5)

Recall the example from the video: Belgium has three official languages, French, German, and Dutch. Conversely, languages can be official in many countries: Dutch is an official language of both the Netherlands and Belgium, but not Germany. Because of the many types of relationships tables can have, there are many ways to join data.

# Inspecting a relationship

You've just identified that the countries table has a many-to-many relationship with the languages table. That is, many languages can be spoken in a country, and a language can be spoken in many countries.

This exercise looks at each of these in turn. First, what is the best way to query all the different languages spoken in a country? And second, how is this different from the best way to query all the countries that speak each language?

Recall that when writing joins, many users prefer to write SQL code out of order by writing the join first (along with any table aliases), and writing the SELECT statement at the end.

1. Start with the join statement in line 6; perform an inner join with the countries table as c on the left with the languages table as l on the right.
Make use of the USING keyword to join on code in line 8.
Lastly, in line 2, select the country name, aliased as country, and the language name, aliased as language.

```
-- Select country and language names, aliased
SELECT 
    c.name AS country,
    l.name AS language
-- From countries (aliased)
FROM 
    countries AS c
-- Join to languages (aliased)
INNER JOIN 
    languages AS l
-- Use code as the joining field with the USING keyword
USING(code);
```

![image](https://github.com/artempohribnyi/datacamp/assets/113499718/b76b50f9-d221-4b52-bfb8-36a23761523a)

2. Rearrange the SELECT statement so that the language column appears on the left and the country column on the right.
Sort the results by language.

```
-- Rearrange SELECT statement, keeping aliases
SELECT l.name AS language, c.name AS country
FROM countries AS c
INNER JOIN languages AS l
USING(code)
-- Order the results by language
ORDER BY language;
```

![image](https://github.com/artempohribnyi/datacamp/assets/113499718/26d601ac-000d-420a-8d87-69469a562b73)


3. Select the incorrect answer from the following options.

The query you generated in step 1 is provided below. Run this query (or the amendment you made in step 2) in the console to find the answer to the question.
```
SELECT c.name AS country, l.name AS language
FROM countries AS c
INNER JOIN languages AS l
USING(code)
ORDER BY country;
```

![image](https://github.com/artempohribnyi/datacamp/assets/113499718/69b31dc9-d584-4d3c-b295-bb0de215009a)

Alsatian is only spoken in France. Well done getting through this exercise. When we read SQL results, we expect the most important column to be on the far left, and it's helpful if results are ordered by relevance to the question at hand. By default, results are ordered by the column from the left table, but you can change this using ORDER BY.

